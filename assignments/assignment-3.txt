
Project Structure:
- Everything looks different! What's going on?
- Structural changes to sspi_flask_app:
    - I've renamed the main file from 'flask_app' to 'sspi_flask_app' just 
    to be super clear.  Minor note but potentially confusing.
    - We are no longer using a single messy app.py file for
    all of our routing and such.  We are "separating our concerns"
    so that we have different "modules" handling different parts of
    the logic.
    - Instead of just plain initiating the application, we are
    using a software engineering design pattern called a "factory
    method" to construct the application.  This is a subtle distinction
    to appreciate, but it gives us better control and extensibility when
    it comes to configuring, debugging, and deploying the app.  For us,
    what's important is that we can't just import the object 'app' of type
    'Flask app', because that object gets returned by the function 'init_app'
    in the __init__.py file at runtime, so it doesn't exist in the global frame.
    This will make our lives a little more challenging, but the difficulty
    is worth the payoff.  Don't worry if all of this doesn't make much sense
    at all...it's finicky weird developer shit and won't affect the overall
    developement process for us very much.
    - Startup process looks like this: 
        1) We type "flask run" into the terminal.  When we do so, the script goes to 
        look in the file called wsgi.py.  WSGI = Web Server Gateway Interface, and its basically 
        the channel through which a server talks to the app we've written.
        2) The file wsgi.py reads in the file __init__.py from the module sspi_flask_app, and it runs
        the line "app = init_app()".  This is the core of the "factory method" design pattern that 
        we talked about before.  Everything that happens to create the app on startup happens inside of
        the function init_app, which means we can pass in.
        3) Within init_app, we do all of our configuration and initialization.  When we add new Blueprints,
        we must register them here.
    - Read through these blog posts for details, they're really good! https://hackersandslackers.com/your-first-flask-application/
    - We are now using Flask Blueprints to handle separation of concerns.  A blueprint is simply a little
    collection of related routes that we tell Flask about through registration in the init_app function in __init__.py.  For example,
    the only part of the application that uses the Login/Registration features we implemented in Assignment 1 are a couple of 
    routes, namely '/login' and '/register'.  Before, all of the logic in these little routes was cluttering up the 
    app.py file, which gets really messy really quickly as we start writing more and more applications.  Now, the logic and the pages for
    user login are hidden away in the 'auth' module.  Each module comprises a .py file which creates the Blueprint and
    specifies the routes, a templates file which holds the html/jinja2 templates for setting up the views, and a
    static file which will hold the css and JavaScript we will use to make the html pretty.
- Setup virtual environment and use the lastest gitignore files to build and
test your app locally.
    - We have a file called requirements.txt in the directory which contains
    a list of all the dependencies and their versions.  This tells anyone looking
    to deploy the app what they'll need to download from the internet to get
    started.  
    - Setup: 
        1) Run "pip install virtualenv" (you might need to use "pip3" instead of "pip")
        2) Pull the updated main branch from github with the requirements.txt file and the updated .gitignore
        3) Create the virtual environment with "python3 -m  venv env"; this generates a folder called 'env'
        which contains 'bin', 'include', and 'lib' subdirectories that constitute a local 
        version of python and its packages in your directory.
        4) To tell python that we are working in a virtual environment, we need to activate it via the
        command "source env/bin/activate," which tells your computer to run the source code called "activate"
        in the folder "env/bin" that we just created.  If all has gone well, you'll see an indication that the
        environment is active with "(env)" appearing in your terminal window.
        5) Now we have a clean virtual environment to work in, but if we try to run our application, it won't
        work because the required packages haven't been loaded.  To load them, run "pip install -r requirements.txt".
        The -r flag tells pip to read the file requirements.txt and install what it finds.  Afterward, you should be
        able to run the app.
        6) After we are finished our work, we can deactivate the virtual environment and return to our global system
        settings by running "deactivate."
    - The gitignore ensures that these files are not tracked in git or on GitHub, so that
    libraries that are implemented differently on different operating systems will not run into 
    conflicts.
    


Action Items:
1) Install MongoDB and MongoSH if you haven't already
2) Watch (and follow along) this tutorial on getting started with MongoDB: https://www.youtube.com/watch?v=ofme2o29ngU&t=496s
3) Read through this set of blog posts on structuring more complex Projects: https://hackersandslackers.com/flask-application-factory/

We're starting to get into the juicy stuff now!

This week's assignment will be focused on writing
code to collect indicator data from online sources
and storing that inside of our database.

The database we will be using for the SSPI is called
MongoDB---short for huMONGOus DataBase.  By the end
of this project, if all goes according to plan, 
we will have a humongous database of our own.

Online data sources---web APIs---generally return in
either JSON (JavaScript Object Notation) or in CSV
(Comma Separated Values) formats.

JSON looks like a python dictionary. Here's an example:

{"country": "Argentina, "year": 2018, 
"indicator": "Deforestation", "value": 15.13}

JSON files can be in lists:

[{"country": "Argentina, "year": 2018, 
"indicator": "Deforestation", "value": 15.13},
{"country": "Austria, "year": 2018, 
"indicator": "Deforestation", "value": 27.14},
{"country": "Australia, "year": 2018, 
"indicator": "Deforestation", "value": 19.43}]

They can also be nested:

x = {"country": {"donor": "Germany", "recipient": "India"}, 
"year": 2018, "indicator": "Foreign Aid", "value": 15.13}

We can access and manipulate values from the JSON object x above
like so:

>>> x["indicator"]
"Foreign Aid"

>>> x["value"]
15.13

>>> x["value"] = 19.31
>>> x["value"]
19.31

>>> x["country"]
{"donor": "Germany", "recipient": "India"}

>>> x["country"]["donor"]
"Germany"


